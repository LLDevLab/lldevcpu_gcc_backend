diff -ruN gcc-releases-gcc-8/config.sub gcc-releases-gcc-8-lldevcpu/config.sub
--- gcc-releases-gcc-8/config.sub	2020-04-15 03:17:00.000000000 +0300
+++ gcc-releases-gcc-8-lldevcpu/config.sub	2020-05-31 10:04:17.000000000 +0300
@@ -265,6 +265,7 @@
 	| k1om \
 	| le32 | le64 \
 	| lm32 \
+	| lldevcpu \
 	| m32c | m32r | m32rle | m68000 | m68k | m88k \
 	| maxq | mb | microblaze | microblazeel | mcore | mep | metag \
 	| mips | mipsbe | mipseb | mipsel | mipsle \
@@ -390,6 +391,7 @@
 	| k1om-* \
 	| le32-* | le64-* \
 	| lm32-* \
+	| lldevcpu-* \
 	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
 	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
diff -ruN gcc-releases-gcc-8/configure gcc-releases-gcc-8-lldevcpu/configure
--- gcc-releases-gcc-8/configure	2020-04-15 03:17:00.000000000 +0300
+++ gcc-releases-gcc-8-lldevcpu/configure	2020-06-09 20:49:12.000000000 +0300
@@ -3,7 +3,7 @@
 # Generated by GNU Autoconf 2.64.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
+# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2020 Free Software
 # Foundation, Inc.
 #
 # This configure script is free software; the Free Software Foundation
@@ -3803,6 +3803,9 @@
   rs6000-*-*)
     noconfigdirs="$noconfigdirs gprof"
     ;;
+  lldevcpu-*-*)
+    noconfigdirs="$noconfigdirs"
+    ;;
   m68k-apollo-*)
     noconfigdirs="$noconfigdirs ld binutils gprof target-libgloss"
     ;;
diff -ruN gcc-releases-gcc-8/configure.ac gcc-releases-gcc-8-lldevcpu/configure.ac
--- gcc-releases-gcc-8/configure.ac	2020-04-15 03:17:00.000000000 +0300
+++ gcc-releases-gcc-8-lldevcpu/configure.ac	2020-06-09 20:50:15.000000000 +0300
@@ -1,6 +1,6 @@
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 #   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012,
-#   2014, 2015, 2016 Free Software Foundation, Inc.
+#   2014, 2015, 2016, 2020 Free Software Foundation, Inc.
 #
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -1134,6 +1134,9 @@
   rs6000-*-*)
     noconfigdirs="$noconfigdirs gprof"
     ;;
+  lldevcpu-*-*)
+    noconfigdirs="$noconfigdirs"
+    ;;
   m68k-apollo-*)
     noconfigdirs="$noconfigdirs ld binutils gprof target-libgloss"
     ;;
diff -ruN gcc-releases-gcc-8/gcc/config/lldevcpu/constraints.md gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/constraints.md
--- gcc-releases-gcc-8/gcc/config/lldevcpu/constraints.md	1970-01-01 03:00:00.000000000 +0300
+++ gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/constraints.md	2020-06-09 20:09:54.000000000 +0300
@@ -0,0 +1,56 @@
+;; Constraint definitions for lldevcpu
+;; Copyright (C) 2009-2020 Free Software Foundation, Inc.
+;; Contributed by LLDevLab <lldevlab@gmail.com>
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published
+;; by the Free Software Foundation; either version 3, or (at your
+;; option) any later version.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; -------------------------------------------------------------------------
+;; Constraints
+;; -------------------------------------------------------------------------
+
+(define_constraint "A"
+  "An absolute address."
+  (and (match_code "mem")
+       (ior (match_test "GET_CODE (XEXP (op, 0)) == SYMBOL_REF")
+	    (match_test "GET_CODE (XEXP (op, 0)) == LABEL_REF")
+	    (match_test "GET_CODE (XEXP (op, 0)) == CONST"))))
+
+(define_constraint "B"
+  "An offset address."
+  (and (match_code "mem")
+       (match_test "lldevcpu_offset_address_p (op)")))
+
+(define_constraint "W"
+  "A register indirect memory operand."
+  (and (match_code "mem")
+       (match_test "REG_P (XEXP (op, 0))
+		    && REGNO_OK_FOR_BASE_P (REGNO (XEXP (op, 0)))")))
+
+(define_constraint "O"
+  "The constant zero"
+  (and (match_code "const_int")
+       (match_test "ival == 0")))
+
+(define_constraint "I"
+  "An 8-bit constant (0..255)"
+  (and (match_code "const_int")
+       (match_test "ival >= 0 && ival <= 255")))
+
+(define_constraint "N"
+  "A constant -(0..255)"
+  (and (match_code "const_int")
+       (match_test "ival >= -255 && ival <= 0")))
diff -ruN gcc-releases-gcc-8/gcc/config/lldevcpu/lldevcpu.c gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/lldevcpu.c
--- gcc-releases-gcc-8/gcc/config/lldevcpu/lldevcpu.c	1970-01-01 03:00:00.000000000 +0300
+++ gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/lldevcpu.c	2020-06-09 20:05:53.000000000 +0300
@@ -0,0 +1,674 @@
+/* Target Code for lldevcpu
+   Copyright (C) 2008-2018 Free Software Foundation, Inc.
+   Contributed by Anthony Green.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#define IN_TARGET_CODE 1
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include "backend.h"
+#include "target.h"
+#include "rtl.h"
+#include "tree.h"
+#include "stringpool.h"
+#include "attribs.h"
+#include "df.h"
+#include "regs.h"
+#include "memmodel.h"
+#include "emit-rtl.h"
+#include "diagnostic-core.h"
+#include "output.h"
+#include "stor-layout.h"
+#include "varasm.h"
+#include "calls.h"
+#include "expr.h"
+#include "builtins.h"
+
+/* This file should be included last.  */
+#include "target-def.h"
+
+#define LOSE_AND_RETURN(msgid, x)		\
+  do						\
+    {						\
+      lldevcpu_operand_lossage (msgid, x);		\
+      return;					\
+    } while (0)
+
+/* Worker function for TARGET_RETURN_IN_MEMORY.  */
+
+static bool
+lldevcpu_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
+{
+  const HOST_WIDE_INT size = int_size_in_bytes (type);
+  return (size == -1 || size > 2 * UNITS_PER_WORD);
+}
+
+/* Define how to find the value returned by a function.
+   VALTYPE is the data type of the value (as a tree).
+   If the precise function being called is known, FUNC is its
+   FUNCTION_DECL; otherwise, FUNC is 0.  
+
+   We always return values in register $r0 for lldevcpu.  */
+
+static rtx
+lldevcpu_function_value (const_tree valtype, 
+		      const_tree fntype_or_decl ATTRIBUTE_UNUSED,
+		      bool outgoing ATTRIBUTE_UNUSED)
+{
+  return gen_rtx_REG (TYPE_MODE (valtype), LLDEVCPU_R0);
+}
+
+/* Define how to find the value returned by a library function.
+
+   We always return values in register $r0 for lldevcpu.  */
+
+static rtx
+lldevcpu_libcall_value (machine_mode mode,
+                     const_rtx fun ATTRIBUTE_UNUSED)
+{
+  return gen_rtx_REG (mode, LLDEVCPU_R0);
+}
+
+/* Handle TARGET_FUNCTION_VALUE_REGNO_P.
+
+   We always return values in register $r0 for lldevcpu.  */
+
+static bool
+lldevcpu_function_value_regno_p (const unsigned int regno)
+{
+  return (regno == LLDEVCPU_R0);
+}
+
+/* Emit an error message when we're in an asm, and a fatal error for
+   "normal" insns.  Formatted output isn't easily implemented, since we
+   use output_operand_lossage to output the actual message and handle the
+   categorization of the error.  */
+
+static void
+lldevcpu_operand_lossage (const char *msgid, rtx op)
+{
+  debug_rtx (op);
+  output_operand_lossage ("%s", msgid);
+}
+
+/* The PRINT_OPERAND_ADDRESS worker.  */
+
+static void
+lldevcpu_print_operand_address (FILE *file, machine_mode, rtx x)
+{
+  switch (GET_CODE (x))
+    {
+    case REG:
+      fprintf (file, "(%s)", reg_names[REGNO (x)]);
+      break;
+      
+    case PLUS:
+      switch (GET_CODE (XEXP (x, 1)))
+	{
+	case CONST_INT:
+	  fprintf (file, "%ld(%s)", 
+		   INTVAL(XEXP (x, 1)), reg_names[REGNO (XEXP (x, 0))]);
+	  break;
+	case SYMBOL_REF:
+	  output_addr_const (file, XEXP (x, 1));
+	  fprintf (file, "(%s)", reg_names[REGNO (XEXP (x, 0))]);
+	  break;
+	case CONST:
+	  {
+	    rtx plus = XEXP (XEXP (x, 1), 0);
+	    if (GET_CODE (XEXP (plus, 0)) == SYMBOL_REF 
+		&& CONST_INT_P (XEXP (plus, 1)))
+	      {
+		output_addr_const(file, XEXP (plus, 0));
+		fprintf (file,"+%ld(%s)", INTVAL (XEXP (plus, 1)),
+			 reg_names[REGNO (XEXP (x, 0))]);
+	      }
+	    else
+	      abort();
+	  }
+	  break;
+	default:
+	  abort();
+	}
+      break;
+
+    default:
+      output_addr_const (file, x);
+      break;
+    }
+}
+
+/* The PRINT_OPERAND worker.  */
+
+static void
+lldevcpu_print_operand (FILE *file, rtx x, int code)
+{
+  rtx operand = x;
+
+  /* New code entries should just be added to the switch below.  If
+     handling is finished, just return.  If handling was just a
+     modification of the operand, the modified operand should be put in
+     "operand", and then do a break to let default handling
+     (zero-modifier) output the operand.  */
+
+  switch (code)
+    {
+    case 0:
+      /* No code, print as usual.  */
+      break;
+
+    default:
+      LOSE_AND_RETURN ("invalid operand modifier letter", x);
+    }
+
+  /* Print an operand as without a modifier letter.  */
+  switch (GET_CODE (operand))
+    {
+    case REG:
+      if (REGNO (operand) > LLDEVCPU_R13)
+	internal_error ("internal error: bad register: %d", REGNO (operand));
+      fprintf (file, "%s", reg_names[REGNO (operand)]);
+      return;
+
+    case MEM:
+      output_address (GET_MODE (XEXP (operand, 0)), XEXP (operand, 0));
+      return;
+
+    default:
+      /* No need to handle all strange variants, let output_addr_const
+	 do it for us.  */
+      if (CONSTANT_P (operand))
+	{
+	  output_addr_const (file, operand);
+	  return;
+	}
+
+      LOSE_AND_RETURN ("unexpected operand", x);
+    }
+}
+
+/* Per-function machine data.  */
+struct GTY(()) machine_function
+ {
+   /* Number of bytes saved on the stack for callee saved registers.  */
+   int callee_saved_reg_size;
+
+   /* Number of bytes saved on the stack for local variables.  */
+   int local_vars_size;
+
+   /* The sum of 2 sizes: locals vars and padding byte for saving the
+    * registers.  Used in expand_prologue () and expand_epilogue().  */
+   int size_for_adjusting_sp;
+ };
+
+/* Zero initialization is OK for all current fields.  */
+
+static struct machine_function *
+lldevcpu_init_machine_status (void)
+{
+  return ggc_cleared_alloc<machine_function> ();
+}
+
+
+/* The TARGET_OPTION_OVERRIDE worker.  */
+static void
+lldevcpu_option_override (void)
+{
+  /* Set the per-function-data initializer.  */
+  init_machine_status = lldevcpu_init_machine_status;
+}
+
+/* Compute the size of the local area and the size to be adjusted by the
+ * prologue and epilogue.  */
+
+static void
+lldevcpu_compute_frame (void)
+{
+  /* For aligning the local variables.  */
+  int stack_alignment = STACK_BOUNDARY / BITS_PER_UNIT;
+  int padding_locals;
+  int regno;
+
+  /* Padding needed for each element of the frame.  */
+  cfun->machine->local_vars_size = get_frame_size ();
+
+  /* Align to the stack alignment.  */
+  padding_locals = cfun->machine->local_vars_size % stack_alignment;
+  if (padding_locals)
+    padding_locals = stack_alignment - padding_locals;
+
+  cfun->machine->local_vars_size += padding_locals;
+
+  cfun->machine->callee_saved_reg_size = 0;
+
+  /* Save callee-saved registers.  */
+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    if (df_regs_ever_live_p (regno) && (! call_used_regs[regno]))
+      cfun->machine->callee_saved_reg_size += 4;
+
+  cfun->machine->size_for_adjusting_sp = 
+    crtl->args.pretend_args_size
+    + cfun->machine->local_vars_size 
+    + (ACCUMULATE_OUTGOING_ARGS
+       ? (HOST_WIDE_INT) crtl->outgoing_args_size : 0);
+}
+
+void
+lldevcpu_expand_prologue (void)
+{
+  int regno;
+  rtx insn;
+
+  lldevcpu_compute_frame ();
+
+  if (flag_stack_usage_info)
+    current_function_static_stack_size = cfun->machine->size_for_adjusting_sp;
+
+  /* Save callee-saved registers.  */
+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+    {
+      if (!fixed_regs[regno] && df_regs_ever_live_p (regno) && !call_used_regs[regno])
+	{
+	  insn = emit_insn (gen_movsi_push (gen_rtx_REG (Pmode, regno)));
+	  RTX_FRAME_RELATED_P (insn) = 1;
+	}
+    }
+
+  if (cfun->machine->size_for_adjusting_sp > 0)
+    {
+      int i = cfun->machine->size_for_adjusting_sp; 
+      while ((i >= 255) && (i <= 510))
+	{
+	  insn = emit_insn (gen_subsi3 (stack_pointer_rtx, 
+					stack_pointer_rtx, 
+					GEN_INT (255)));
+	  RTX_FRAME_RELATED_P (insn) = 1;
+	  i -= 255;
+	}
+      if (i <= 255)
+	{
+	  insn = emit_insn (gen_subsi3 (stack_pointer_rtx, 
+					stack_pointer_rtx, 
+					GEN_INT (i)));
+	  RTX_FRAME_RELATED_P (insn) = 1;
+	}
+      else
+	{
+	  rtx reg = gen_rtx_REG (SImode, LLDEVCPU_R12);
+	  insn = emit_move_insn (reg, GEN_INT (i));
+	  RTX_FRAME_RELATED_P (insn) = 1;
+	  insn = emit_insn (gen_subsi3 (stack_pointer_rtx, 
+					stack_pointer_rtx, 
+					reg));
+	  RTX_FRAME_RELATED_P (insn) = 1;
+	}
+    }
+}
+
+void
+lldevcpu_expand_epilogue (void)
+{
+  int regno;
+  rtx reg;
+
+  if (cfun->machine->callee_saved_reg_size != 0)
+    {
+      reg = gen_rtx_REG (Pmode, LLDEVCPU_R12);
+      if (cfun->machine->callee_saved_reg_size <= 255)
+	{
+	  emit_move_insn (reg, hard_frame_pointer_rtx);
+	  emit_insn (gen_subsi3 
+		     (reg, reg, 
+		      GEN_INT (cfun->machine->callee_saved_reg_size)));
+	}
+      else
+	{
+	  emit_move_insn (reg,
+			  GEN_INT (-cfun->machine->callee_saved_reg_size));
+	  emit_insn (gen_addsi3 (reg, reg, hard_frame_pointer_rtx));
+	}
+      for (regno = FIRST_PSEUDO_REGISTER; regno-- > 0; )
+	if (!fixed_regs[regno] && !call_used_regs[regno]
+	    && df_regs_ever_live_p (regno))
+	  {
+	    rtx preg = gen_rtx_REG (Pmode, regno);
+	    emit_insn (gen_movsi_pop (reg, preg));
+	  }
+    }
+
+  emit_jump_insn (gen_returner ());
+}
+
+/* Implements the macro INITIAL_ELIMINATION_OFFSET, return the OFFSET.  */
+
+int
+lldevcpu_initial_elimination_offset (int from, int to)
+{
+  int ret;
+  
+  if ((from) == FRAME_POINTER_REGNUM && (to) == HARD_FRAME_POINTER_REGNUM)
+    {
+      /* Compute this since we need to use cfun->machine->local_vars_size.  */
+      lldevcpu_compute_frame ();
+      ret = -cfun->machine->callee_saved_reg_size;
+    }
+  else if ((from) == ARG_POINTER_REGNUM && (to) == HARD_FRAME_POINTER_REGNUM)
+    ret = 0x00;
+  else
+    abort ();
+
+  return ret;
+}
+
+/* Worker function for TARGET_SETUP_INCOMING_VARARGS.  */
+
+static void
+lldevcpu_setup_incoming_varargs (cumulative_args_t cum_v,
+			      machine_mode mode ATTRIBUTE_UNUSED,
+			      tree type ATTRIBUTE_UNUSED,
+			      int *pretend_size, int no_rtl)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+  int regno;
+  int regs = 8 - *cum;
+  
+  *pretend_size = regs < 0 ? 0 : GET_MODE_SIZE (SImode) * regs;
+  
+  if (no_rtl)
+    return;
+  
+  for (regno = *cum; regno < 8; regno++)
+    {
+      rtx reg = gen_rtx_REG (SImode, regno);
+      rtx slot = gen_rtx_PLUS (Pmode,
+			       gen_rtx_REG (SImode, ARG_POINTER_REGNUM),
+			       GEN_INT (UNITS_PER_WORD * (3 + (regno-2))));
+      
+      emit_move_insn (gen_rtx_MEM (SImode, slot), reg);
+    }
+}
+
+
+/* Return the fixed registers used for condition codes.  */
+
+static bool
+lldevcpu_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)
+{
+  *p1 = CC_REG;
+  *p2 = INVALID_REGNUM;
+  return true;
+}
+
+/* Return the next register to be used to hold a function argument or
+   NULL_RTX if there's no more space.  */
+
+static rtx
+lldevcpu_function_arg (cumulative_args_t cum_v, machine_mode mode,
+		    const_tree type ATTRIBUTE_UNUSED,
+		    bool named ATTRIBUTE_UNUSED)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+
+  if (*cum < 8)
+    return gen_rtx_REG (mode, *cum);
+  else 
+    return NULL_RTX;
+}
+
+#define LLDEVCPU_FUNCTION_ARG_SIZE(MODE, TYPE)	\
+  ((MODE) != BLKmode ? GET_MODE_SIZE (MODE)	\
+   : (unsigned) int_size_in_bytes (TYPE))
+
+static void
+lldevcpu_function_arg_advance (cumulative_args_t cum_v, machine_mode mode,
+			    const_tree type, bool named ATTRIBUTE_UNUSED)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+
+  *cum = (*cum < LLDEVCPU_R6
+	  ? *cum + ((3 + LLDEVCPU_FUNCTION_ARG_SIZE (mode, type)) / 4)
+	  : *cum);
+}
+
+/* Return non-zero if the function argument described by TYPE is to be
+   passed by reference.  */
+
+static bool
+lldevcpu_pass_by_reference (cumulative_args_t cum ATTRIBUTE_UNUSED,
+			 machine_mode mode, const_tree type,
+			 bool named ATTRIBUTE_UNUSED)
+{
+  unsigned HOST_WIDE_INT size;
+
+  if (type)
+    {
+      if (AGGREGATE_TYPE_P (type))
+	return true;
+      size = int_size_in_bytes (type);
+    }
+  else
+    size = GET_MODE_SIZE (mode);
+
+  return size > 4*6;
+}
+
+/* Some function arguments will only partially fit in the registers
+   that hold arguments.  Given a new arg, return the number of bytes
+   that fit in argument passing registers.  */
+
+static int
+lldevcpu_arg_partial_bytes (cumulative_args_t cum_v,
+			 machine_mode mode,
+			 tree type, bool named)
+{
+  CUMULATIVE_ARGS *cum = get_cumulative_args (cum_v);
+  int bytes_left, size;
+
+  if (*cum >= 8)
+    return 0;
+
+  if (lldevcpu_pass_by_reference (cum_v, mode, type, named))
+    size = 4;
+  else if (type)
+    {
+      if (AGGREGATE_TYPE_P (type))
+	return 0;
+      size = int_size_in_bytes (type);
+    }
+  else
+    size = GET_MODE_SIZE (mode);
+
+  bytes_left = (4 * 6) - ((*cum - 2) * 4);
+
+  if (size > bytes_left)
+    return bytes_left;
+  else
+    return 0;
+}
+
+/* Worker function for TARGET_STATIC_CHAIN.  */
+
+static rtx
+lldevcpu_static_chain (const_tree ARG_UNUSED (fndecl_or_type), bool incoming_p)
+{
+  rtx addr, mem;
+
+  if (incoming_p)
+    addr = plus_constant (Pmode, arg_pointer_rtx, 2 * UNITS_PER_WORD);
+  else
+    addr = plus_constant (Pmode, stack_pointer_rtx, -UNITS_PER_WORD);
+
+  mem = gen_rtx_MEM (Pmode, addr);
+  MEM_NOTRAP_P (mem) = 1;
+
+  return mem;
+}
+
+/* Worker function for TARGET_ASM_TRAMPOLINE_TEMPLATE.  */
+
+static void
+lldevcpu_asm_trampoline_template (FILE *f)
+{
+  fprintf (f, "\tpush  $sp, $r0\n");
+  fprintf (f, "\tldi.l $r0, 0x0\n");
+  fprintf (f, "\tsto.l 0x8($fp), $r0\n");
+  fprintf (f, "\tpop   $sp, $r0\n");
+  fprintf (f, "\tjmpa  0x0\n");
+}
+
+/* Worker function for TARGET_TRAMPOLINE_INIT.  */
+
+static void
+lldevcpu_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)
+{
+  rtx mem, fnaddr = XEXP (DECL_RTL (fndecl), 0);
+
+  emit_block_move (m_tramp, assemble_trampoline_template (),
+		   GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);
+
+  mem = adjust_address (m_tramp, SImode, 4);
+  emit_move_insn (mem, chain_value);
+  mem = adjust_address (m_tramp, SImode, 16);
+  emit_move_insn (mem, fnaddr);
+}
+
+/* Return true for memory offset addresses between -32768 and 32767.  */
+bool
+lldevcpu_offset_address_p (rtx x)
+{
+  x = XEXP (x, 0);
+
+  if (GET_CODE (x) == PLUS)
+    {
+      x = XEXP (x, 1);
+      if (GET_CODE (x) == CONST_INT)
+	{
+	  unsigned int v = INTVAL (x) & 0xFFFF8000;
+	  return (v == 0xFFFF8000 || v == 0x00000000);
+	}
+    }
+  return 0;
+}
+
+/* Helper function for `lldevcpu_legitimate_address_p'.  */
+
+static bool
+lldevcpu_reg_ok_for_base_p (const_rtx reg, bool strict_p)
+{
+  int regno = REGNO (reg);
+
+  if (strict_p)
+    return HARD_REGNO_OK_FOR_BASE_P (regno)
+	   || HARD_REGNO_OK_FOR_BASE_P (reg_renumber[regno]);
+  else    
+    return !HARD_REGISTER_NUM_P (regno)
+	   || HARD_REGNO_OK_FOR_BASE_P (regno);
+}
+
+/* Worker function for TARGET_LEGITIMATE_ADDRESS_P.  */
+
+static bool
+lldevcpu_legitimate_address_p (machine_mode mode ATTRIBUTE_UNUSED,
+			    rtx x, bool strict_p,
+			    addr_space_t as)
+{
+  gcc_assert (ADDR_SPACE_GENERIC_P (as));
+
+  if (GET_CODE(x) == PLUS
+      && REG_P (XEXP (x, 0))
+      && lldevcpu_reg_ok_for_base_p (XEXP (x, 0), strict_p)
+      && CONST_INT_P (XEXP (x, 1))
+      && IN_RANGE (INTVAL (XEXP (x, 1)), -32768, 32767))
+    return true;
+  if (REG_P (x) && lldevcpu_reg_ok_for_base_p (x, strict_p))
+    return true;
+  if (GET_CODE (x) == SYMBOL_REF
+      || GET_CODE (x) == LABEL_REF
+      || GET_CODE (x) == CONST)
+    return true;
+  return false;
+}
+
+/* The Global `targetm' Variable.  */
+
+/* Initialize the GCC target structure.  */
+
+#undef  TARGET_PROMOTE_PROTOTYPES
+#define TARGET_PROMOTE_PROTOTYPES	hook_bool_const_tree_true
+
+#undef  TARGET_RETURN_IN_MEMORY
+#define TARGET_RETURN_IN_MEMORY		lldevcpu_return_in_memory
+#undef  TARGET_MUST_PASS_IN_STACK
+#define TARGET_MUST_PASS_IN_STACK	must_pass_in_stack_var_size
+#undef  TARGET_PASS_BY_REFERENCE
+#define TARGET_PASS_BY_REFERENCE        lldevcpu_pass_by_reference
+#undef  TARGET_ARG_PARTIAL_BYTES
+#define TARGET_ARG_PARTIAL_BYTES        lldevcpu_arg_partial_bytes
+#undef  TARGET_FUNCTION_ARG
+#define TARGET_FUNCTION_ARG		lldevcpu_function_arg
+#undef  TARGET_FUNCTION_ARG_ADVANCE
+#define TARGET_FUNCTION_ARG_ADVANCE	lldevcpu_function_arg_advance
+
+#undef TARGET_LRA_P
+#define TARGET_LRA_P hook_bool_void_false
+
+#undef  TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P
+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P	lldevcpu_legitimate_address_p
+
+#undef  TARGET_SETUP_INCOMING_VARARGS
+#define TARGET_SETUP_INCOMING_VARARGS 	lldevcpu_setup_incoming_varargs
+
+#undef	TARGET_FIXED_CONDITION_CODE_REGS
+#define	TARGET_FIXED_CONDITION_CODE_REGS lldevcpu_fixed_condition_code_regs
+
+/* Define this to return an RTX representing the place where a
+   function returns or receives a value of data type RET_TYPE, a tree
+   node representing a data type.  */
+#undef TARGET_FUNCTION_VALUE
+#define TARGET_FUNCTION_VALUE lldevcpu_function_value
+#undef TARGET_LIBCALL_VALUE
+#define TARGET_LIBCALL_VALUE lldevcpu_libcall_value
+#undef TARGET_FUNCTION_VALUE_REGNO_P
+#define TARGET_FUNCTION_VALUE_REGNO_P lldevcpu_function_value_regno_p
+
+#undef TARGET_FRAME_POINTER_REQUIRED
+#define TARGET_FRAME_POINTER_REQUIRED hook_bool_void_true
+
+#undef TARGET_STATIC_CHAIN
+#define TARGET_STATIC_CHAIN lldevcpu_static_chain
+#undef TARGET_ASM_TRAMPOLINE_TEMPLATE
+#define TARGET_ASM_TRAMPOLINE_TEMPLATE lldevcpu_asm_trampoline_template
+#undef TARGET_TRAMPOLINE_INIT
+#define TARGET_TRAMPOLINE_INIT lldevcpu_trampoline_init
+
+#undef TARGET_OPTION_OVERRIDE
+#define TARGET_OPTION_OVERRIDE lldevcpu_option_override
+
+#undef  TARGET_PRINT_OPERAND
+#define TARGET_PRINT_OPERAND lldevcpu_print_operand
+#undef  TARGET_PRINT_OPERAND_ADDRESS
+#define TARGET_PRINT_OPERAND_ADDRESS lldevcpu_print_operand_address
+
+#undef  TARGET_CONSTANT_ALIGNMENT
+#define TARGET_CONSTANT_ALIGNMENT constant_alignment_word_strings
+
+struct gcc_target targetm = TARGET_INITIALIZER;
+
+#include "gt-lldevcpu.h"
diff -ruN gcc-releases-gcc-8/gcc/config/lldevcpu/lldevcpu.h gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/lldevcpu.h
--- gcc-releases-gcc-8/gcc/config/lldevcpu/lldevcpu.h	1970-01-01 03:00:00.000000000 +0300
+++ gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/lldevcpu.h	2020-06-09 20:07:20.000000000 +0300
@@ -0,0 +1,428 @@
+/* Target Definitions for lldevcpu.
+   Copyright (C) 2008-2018 Free Software Foundation, Inc.
+   Contributed by Anthony Green.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef GCC_LLDEVCPU_H
+#define GCC_LLDEVCPU_H
+
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC "%{!mno-crt0:crt0%O%s} crti.o%s crtbegin.o%s"
+
+/* Provide an ENDFILE_SPEC appropriate for svr4.  Here we tack on our own
+   magical crtend.o file (see crtstuff.c) which provides part of the
+   support for getting C++ file-scope static object constructed before
+   entering `main', followed by the normal svr3/svr4 "finalizer" file,
+   which is either `gcrtn.o' or `crtn.o'.  */
+
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC "crtend.o%s crtn.o%s"
+
+/* Provide a LIB_SPEC appropriate for svr4.  Here we tack on the default
+   standard C library (unless we are building a shared library) and
+   the simulator BSP code.  */
+
+#undef LIB_SPEC
+#define LIB_SPEC "%{!shared:%{!symbolic:-lc}}"
+
+#undef  LINK_SPEC
+#define LINK_SPEC "%{h*} %{v:-V} %{!mel:-EB} %{mel:-EL}\
+		   %{static:-Bstatic} %{shared:-shared} %{symbolic:-Bsymbolic}"
+
+#ifndef MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS { "meb" }
+#endif
+
+/* Layout of Source Language Data Types */
+
+#define INT_TYPE_SIZE 32
+#define SHORT_TYPE_SIZE 16
+#define LONG_TYPE_SIZE 32
+#define LONG_LONG_TYPE_SIZE 64
+
+#define FLOAT_TYPE_SIZE 32
+#define DOUBLE_TYPE_SIZE 64
+#define LONG_DOUBLE_TYPE_SIZE 64
+
+#define DEFAULT_SIGNED_CHAR 0
+
+#undef  SIZE_TYPE
+#define SIZE_TYPE "unsigned int"
+
+#undef  PTRDIFF_TYPE
+#define PTRDIFF_TYPE "int"
+
+#undef  WCHAR_TYPE
+#define WCHAR_TYPE "unsigned int"
+
+#undef  WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE BITS_PER_WORD
+
+/* Registers...
+
+   $fp  - frame pointer
+   $sp  - stack pointer
+   $r0  - general purpose 32-bit register.
+   $r1  - general purpose 32-bit register.
+   $r2  - general purpose 32-bit register.
+   $r3  - general purpose 32-bit register.
+   $r4  - general purpose 32-bit register.
+   $r5  - general purpose 32-bit register.
+   $r6  - general purpose 32-bit register.
+   $r7  - general purpose 32-bit register.
+   $r8  - general purpose 32-bit register.
+   $r9  - general purpose 32-bit register.
+   $r10 - general purpose 32-bit register.
+   $r11 - general purpose 32-bit register.
+   $r12 - general purpose 32-bit register.
+   $r13 - reserved for execution environment.
+
+   Special Registers...
+
+   $pc - 32-bit program counter.
+   
+*/
+
+#define REGISTER_NAMES {	\
+  "$fp", "$sp", "$r0", "$r1",   \
+  "$r2", "$r3", "$r4", "$r5",   \
+  "$r6", "$r7", "$r8", "$r9",   \
+  "$r10", "$r11", "$r12", "$r13",   \
+  "?fp", "?ap", "$pc", "?cc" }
+
+#define LLDEVCPU_FP     0
+#define LLDEVCPU_SP     1
+#define LLDEVCPU_R0     2
+#define LLDEVCPU_R1     3 
+#define LLDEVCPU_R2     4
+#define LLDEVCPU_R3     5
+#define LLDEVCPU_R4     6
+#define LLDEVCPU_R5     7
+#define LLDEVCPU_R6     8
+#define LLDEVCPU_R7     9
+#define LLDEVCPU_R8     10
+#define LLDEVCPU_R9     11
+#define LLDEVCPU_R10    12
+#define LLDEVCPU_R11    13
+#define LLDEVCPU_R12    14
+#define LLDEVCPU_R13    15
+#define LLDEVCPU_QFP    16
+#define LLDEVCPU_QAP    17
+#define LLDEVCPU_PC     18
+#define LLDEVCPU_CC     19
+
+#define FIRST_PSEUDO_REGISTER 20
+
+enum reg_class
+{
+  NO_REGS,
+  GENERAL_REGS,
+  SPECIAL_REGS,
+  CC_REGS,
+  ALL_REGS,
+  LIM_REG_CLASSES
+};
+
+
+#define REG_CLASS_CONTENTS \
+{ { 0x00000000 }, /* Empty */			   \
+  { 0x0003FFFF }, /* $fp, $sp, $r0 to $r13, ?fp */ \
+  { 0x00040000 }, /* $pc */	                   \
+  { 0x00080000 }, /* ?cc */                        \
+  { 0x000FFFFF }  /* All registers */              \
+}
+
+#define N_REG_CLASSES LIM_REG_CLASSES
+
+#define REG_CLASS_NAMES {\
+    "NO_REGS", \
+    "GENERAL_REGS", \
+    "SPECIAL_REGS", \
+    "CC_REGS", \
+    "ALL_REGS" }
+
+#define FIXED_REGISTERS     { 1, 1, 0, 0, \
+			      0, 0, 0, 0, \
+			      0, 0, 0, 0, \
+			      0, 0, 0, 1, \
+                              1, 1, 1, 1 }
+
+#define CALL_USED_REGISTERS { 1, 1, 1, 1, \
+			      1, 1, 1, 1, \
+			      0, 0, 0, 0, \
+			      0, 0, 1, 1, \
+                              1, 1, 1, 1 }
+
+/* We can't copy to or from our CC register. */
+#define AVOID_CCMODE_COPIES 1
+
+/* A C expression whose value is a register class containing hard
+   register REGNO.  */
+#define REGNO_REG_CLASS(R) ((R < LLDEVCPU_PC) ? GENERAL_REGS :		\
+                            (R == LLDEVCPU_CC ? CC_REGS : SPECIAL_REGS))
+
+/* The Overall Framework of an Assembler File */
+
+#undef  ASM_SPEC
+#define ASM_SPEC "%{!mel:-EB} %{mel:-EL}"
+#define ASM_COMMENT_START "#"
+#define ASM_APP_ON ""
+#define ASM_APP_OFF ""
+
+#define FILE_ASM_OP     "\t.file\n"
+
+/* Switch to the text or data segment.  */
+#define TEXT_SECTION_ASM_OP  "\t.text"
+#define DATA_SECTION_ASM_OP  "\t.data"
+
+/* Assembler Commands for Alignment */
+
+#define ASM_OUTPUT_ALIGN(STREAM,POWER) \
+	fprintf (STREAM, "\t.p2align\t%d\n", POWER);
+
+/* Output and Generation of Labels */
+
+#define GLOBAL_ASM_OP "\t.global\t"
+
+/* Passing Arguments in Registers */
+
+/* A C type for declaring a variable that is used as the first
+   argument of `FUNCTION_ARG' and other related values.  */
+#define CUMULATIVE_ARGS unsigned int
+
+/* If defined, the maximum amount of space required for outgoing arguments
+   will be computed and placed into the variable
+   `current_function_outgoing_args_size'.  No space will be pushed
+   onto the stack for each call; instead, the function prologue should
+   increase the stack frame size by this amount.  */
+#define ACCUMULATE_OUTGOING_ARGS 1
+
+/* A C statement (sans semicolon) for initializing the variable CUM
+   for the state at the beginning of the argument list.  
+   For LLDEVCPU, the first arg is passed in register 2 (aka $r0).  */
+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,FNDECL,N_NAMED_ARGS) \
+  (CUM = LLDEVCPU_R0)
+
+/* How Scalar Function Values Are Returned */
+
+/* STACK AND CALLING */
+
+/* Define this macro if pushing a word onto the stack moves the stack
+   pointer to a smaller address.  */
+#define STACK_GROWS_DOWNWARD 1
+
+/* Define this if the above stack space is to be considered part of the
+   space allocated by the caller.  */
+#define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 1
+#define STACK_PARMS_IN_REG_PARM_AREA
+
+/* Define this if it is the responsibility of the caller to allocate
+   the area reserved for arguments passed in registers.  */
+#define REG_PARM_STACK_SPACE(FNDECL) (6 * UNITS_PER_WORD)
+
+/* Offset from the argument pointer register to the first argument's
+   address.  On some machines it may depend on the data type of the
+   function.  */
+#define FIRST_PARM_OFFSET(F) 12
+
+/* Define this macro to nonzero value if the addresses of local variable slots
+   are at negative offsets from the frame pointer.  */
+#define FRAME_GROWS_DOWNWARD 1
+
+/* Define this macro as a C expression that is nonzero for registers that are
+   used by the epilogue or the return pattern.  The stack and frame
+   pointer registers are already assumed to be used as needed.  */
+#define EPILOGUE_USES(R) (R == LLDEVCPU_R5)
+
+/* A C expression whose value is RTL representing the location of the
+   incoming return address at the beginning of any function, before
+   the prologue.  */
+#define INCOMING_RETURN_ADDR_RTX					\
+  gen_frame_mem (Pmode,							\
+		 plus_constant (Pmode, stack_pointer_rtx, UNITS_PER_WORD))
+
+/* Describe how we implement __builtin_eh_return.  */
+#define EH_RETURN_DATA_REGNO(N)	((N) < 4 ? (N+2) : INVALID_REGNUM)
+
+/* Store the return handler into the call frame.  */
+#define EH_RETURN_HANDLER_RTX						\
+  gen_frame_mem (Pmode,							\
+		 plus_constant (Pmode, frame_pointer_rtx, UNITS_PER_WORD))
+
+/* Storage Layout */
+
+#define BITS_BIG_ENDIAN 0
+#define BYTES_BIG_ENDIAN ( ! TARGET_LITTLE_ENDIAN )
+#define WORDS_BIG_ENDIAN ( ! TARGET_LITTLE_ENDIAN )
+
+/* Alignment required for a function entry point, in bits.  */
+#define FUNCTION_BOUNDARY 16
+
+/* Define this macro as a C expression which is nonzero if accessing
+   less than a word of memory (i.e. a `char' or a `short') is no
+   faster than accessing a word of memory.  */
+#define SLOW_BYTE_ACCESS 1
+
+/* Number of storage units in a word; normally the size of a
+   general-purpose register, a power of two from 1 or 8.  */
+#define UNITS_PER_WORD 4
+
+/* Define this macro to the minimum alignment enforced by hardware
+   for the stack pointer on this machine.  The definition is a C
+   expression for the desired alignment (measured in bits).  */
+#define STACK_BOUNDARY 32
+
+/* Normal alignment required for function parameters on the stack, in
+   bits.  All stack parameters receive at least this much alignment
+   regardless of data type.  */
+#define PARM_BOUNDARY 32
+
+/* Alignment of field after `int : 0' in a structure.  */
+#define EMPTY_FIELD_BOUNDARY  32
+
+/* No data type wants to be aligned rounder than this.  */
+#define BIGGEST_ALIGNMENT 32
+
+/* The best alignment to use in cases where we have a choice.  */
+#define FASTEST_ALIGNMENT 32
+
+/* Every structures size must be a multiple of 8 bits.  */
+#define STRUCTURE_SIZE_BOUNDARY 8
+
+/* Look at the fundamental type that is used for a bit-field and use 
+   that to impose alignment on the enclosing structure.
+   struct s {int a:8}; should have same alignment as "int", not "char".  */
+#define	PCC_BITFIELD_TYPE_MATTERS	1
+
+/* Largest integer machine mode for structures.  If undefined, the default
+   is GET_MODE_SIZE(DImode).  */
+#define MAX_FIXED_MODE_SIZE 32
+
+/* Make arrays of chars word-aligned for the same reasons.  */
+#define DATA_ALIGNMENT(TYPE, ALIGN)		\
+  (TREE_CODE (TYPE) == ARRAY_TYPE		\
+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode	\
+   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))
+     
+/* Set this nonzero if move instructions will actually fail to work
+   when given unaligned data.  */
+#define STRICT_ALIGNMENT 1
+
+/* Generating Code for Profiling */
+#define FUNCTION_PROFILER(FILE,LABELNO) (abort (), 0)
+
+/* Trampolines for Nested Functions.  */
+#define TRAMPOLINE_SIZE (2 + 6 + 4 + 2 + 6)
+
+/* Alignment required for trampolines, in bits.  */
+#define TRAMPOLINE_ALIGNMENT 32
+
+/* An alias for the machine mode for pointers.  */
+#define Pmode         SImode
+
+/* An alias for the machine mode used for memory references to
+   functions being called, in `call' RTL expressions.  */
+#define FUNCTION_MODE QImode
+
+/* The register number of the stack pointer register, which must also
+   be a fixed register according to `FIXED_REGISTERS'.  */
+#define STACK_POINTER_REGNUM LLDEVCPU_SP
+
+/* The register number of the frame pointer register, which is used to
+   access automatic variables in the stack frame.  */
+#define FRAME_POINTER_REGNUM LLDEVCPU_QFP
+
+/* The register number of the arg pointer register, which is used to
+   access the function's argument list.  */
+#define ARG_POINTER_REGNUM LLDEVCPU_QAP
+
+#define HARD_FRAME_POINTER_REGNUM LLDEVCPU_FP
+
+#define ELIMINABLE_REGS							\
+{{ FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM },			\
+ { ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM }}			
+
+/* This macro returns the initial difference between the specified pair
+   of registers.  */
+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)			\
+  do {									\
+    (OFFSET) = lldevcpu_initial_elimination_offset ((FROM), (TO));		\
+  } while (0)
+
+/* A C expression that is nonzero if REGNO is the number of a hard
+   register in which function arguments are sometimes passed.  */
+#define FUNCTION_ARG_REGNO_P(r) (r >= LLDEVCPU_R0 && r <= LLDEVCPU_R5)
+
+/* A macro whose definition is the name of the class to which a valid
+   base register must belong.  A base register is one used in an
+   address which is the register value plus a displacement.  */
+#define BASE_REG_CLASS GENERAL_REGS
+
+#define INDEX_REG_CLASS NO_REGS
+
+#define HARD_REGNO_OK_FOR_BASE_P(NUM) \
+  ((unsigned) (NUM) < FIRST_PSEUDO_REGISTER \
+   && (REGNO_REG_CLASS(NUM) == GENERAL_REGS \
+       || (NUM) == HARD_FRAME_POINTER_REGNUM))
+
+/* A C expression which is nonzero if register number NUM is suitable
+   for use as a base register in operand addresses.  */
+#ifdef REG_OK_STRICT
+#define REGNO_OK_FOR_BASE_P(NUM)		 \
+  (HARD_REGNO_OK_FOR_BASE_P(NUM) 		 \
+   || HARD_REGNO_OK_FOR_BASE_P(reg_renumber[(NUM)]))
+#else
+#define REGNO_OK_FOR_BASE_P(NUM)		 \
+  ((NUM) >= FIRST_PSEUDO_REGISTER || HARD_REGNO_OK_FOR_BASE_P(NUM))
+#endif
+
+/* A C expression which is nonzero if register number NUM is suitable
+   for use as an index register in operand addresses.  */
+#define REGNO_OK_FOR_INDEX_P(NUM) LLDEVCPU_FP
+
+/* The maximum number of bytes that a single instruction can move
+   quickly between memory and registers or between two memory
+   locations.  */
+#define MOVE_MAX 4
+
+/* All load operations zero extend.  */
+#define LOAD_EXTEND_OP(MEM) ZERO_EXTEND
+
+/* A number, the maximum number of registers that can appear in a
+   valid memory address.  */
+#define MAX_REGS_PER_ADDRESS 1
+
+/* An alias for a machine mode name.  This is the machine mode that
+   elements of a jump-table should have.  */
+#define CASE_VECTOR_MODE SImode
+
+/* Run-time Target Specification */
+
+#define TARGET_CPU_CPP_BUILTINS() \
+  { \
+    builtin_define_std ("LLDEVCPU");			\
+    builtin_define_std ("LLDEVCPU");			\
+    if (TARGET_LITTLE_ENDIAN)				\
+      builtin_define ("__LLDEVCPU_LITTLE_ENDIAN__");	\
+    else						\
+      builtin_define ("__LLDEVCPU_BIG_ENDIAN__");		\
+  }
+
+#define HAS_LONG_UNCOND_BRANCH true
+
+#endif /* GCC_LLDEVCPU_H */
diff -ruN gcc-releases-gcc-8/gcc/config/lldevcpu/lldevcpu.md gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/lldevcpu.md
--- gcc-releases-gcc-8/gcc/config/lldevcpu/lldevcpu.md	1970-01-01 03:00:00.000000000 +0300
+++ gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/lldevcpu.md	2020-06-09 20:11:19.000000000 +0300
@@ -0,0 +1,517 @@
+;; Machine description for lldevcpu
+;; Copyright (C) 2009-2020 Free Software Foundation, Inc.
+;; Contributed by LLDevLab <lldevlab@gmail.com>
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published
+;; by the Free Software Foundation; either version 3, or (at your
+;; option) any later version.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; -------------------------------------------------------------------------
+;; lldevcpu specific constraints, predicates and attributes
+;; -------------------------------------------------------------------------
+
+(include "constraints.md")
+(include "predicates.md")
+
+; Most instructions are two bytes long.
+(define_attr "length" "" (const_int 2))
+
+;; -------------------------------------------------------------------------
+;; nop instruction
+;; -------------------------------------------------------------------------
+
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "nop")
+
+;; -------------------------------------------------------------------------
+;; Arithmetic instructions
+;; -------------------------------------------------------------------------
+
+(define_insn "addsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
+	  (plus:SI
+	   (match_operand:SI 1 "register_operand" "0,0,0")
+	   (match_operand:SI 2 "lldevcpu_add_operand" "I,N,r")))]
+  ""
+  "@
+  inc\\t%0, %2
+  dec\\t%0, -%2
+  add\\t%0, %2")
+
+(define_insn "subsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	  (minus:SI
+	   (match_operand:SI 1 "register_operand" "0,0")
+	   (match_operand:SI 2 "lldevcpu_sub_operand" "I,r")))]
+  ""
+  "@
+  dec\\t%0, %2
+  sub\\t%0, %2")
+
+(define_insn "mulsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	  (mult:SI
+	   (match_operand:SI 1 "register_operand" "0")
+	   (match_operand:SI 2 "register_operand" "r")))]
+  ""
+  "mul\\t%0, %2")
+
+(define_code_iterator EXTEND [sign_extend zero_extend])
+(define_code_attr mul [(sign_extend "mul") (zero_extend "umul")])
+
+(define_insn "<mul>si3_highpart"
+  [(set (match_operand:SI 0 "register_operand"                       "=r")
+        (truncate:SI
+         (lshiftrt:DI
+          (mult:DI (EXTEND:DI (match_operand:SI 1 "register_operand"  "0"))
+                   (EXTEND:DI (match_operand:SI 2 "register_operand"  "r")))
+          (const_int 32))))]
+  "TARGET_HAS_MULX"
+  "<mul>.x\\t%0, %2")
+
+(define_expand "<mul>sidi3"
+  [(set (match_operand:DI 0 "register_operand" "")
+	(mult:DI (EXTEND:DI (match_operand:SI 1 "register_operand" "0"))
+		 (EXTEND:DI (match_operand:SI 2 "register_operand" "r"))))]
+  "TARGET_HAS_MULX"
+{
+  rtx hi = gen_reg_rtx (SImode);
+  rtx lo = gen_reg_rtx (SImode);
+
+  emit_insn (gen_<mul>si3_highpart (hi, operands[1], operands[2]));
+  emit_insn (gen_mulsi3 (lo, operands[1], operands[2]));
+  emit_move_insn (gen_lowpart (SImode, operands[0]), lo);
+  emit_move_insn (gen_highpart (SImode, operands[0]), hi);
+  DONE;
+})
+
+(define_insn "divsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	  (div:SI
+	   (match_operand:SI 1 "register_operand" "0")
+	   (match_operand:SI 2 "register_operand" "r")))]
+  ""
+  "div\\t%0, %2")
+
+(define_insn "udivsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	  (udiv:SI
+	   (match_operand:SI 1 "register_operand" "0")
+	   (match_operand:SI 2 "register_operand" "r")))]
+  ""
+  "udiv\\t%0, %2")
+
+(define_insn "modsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	  (mod:SI
+	   (match_operand:SI 1 "register_operand" "0")
+	   (match_operand:SI 2 "register_operand" "r")))]
+  ""
+  "mod\\t%0, %2")
+
+(define_insn "umodsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	  (umod:SI
+	   (match_operand:SI 1 "register_operand" "0")
+	   (match_operand:SI 2 "register_operand" "r")))]
+  ""
+  "umod\\t%0, %2")
+
+;; -------------------------------------------------------------------------
+;; Unary arithmetic instructions
+;; -------------------------------------------------------------------------
+
+(define_insn "negsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	  (neg:SI (match_operand:SI 1 "register_operand" "r")))]
+  ""
+  "neg\\t%0, %1")
+
+(define_insn "one_cmplsi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(not:SI (match_operand:SI 1 "register_operand" "r")))]
+  ""
+  "not\\t%0, %1")
+
+;; -------------------------------------------------------------------------
+;; Logical operators
+;; -------------------------------------------------------------------------
+
+(define_insn "andsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(and:SI (match_operand:SI 1 "register_operand" "0")
+		(match_operand:SI 2 "register_operand" "r")))]
+  ""
+{
+  return "and\\t%0, %2";
+})
+
+(define_insn "xorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(xor:SI (match_operand:SI 1 "register_operand" "0")
+		(match_operand:SI 2 "register_operand" "r")))]
+  ""
+{
+  return "xor\\t%0, %2";
+})
+
+(define_insn "iorsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (match_operand:SI 1 "register_operand" "0")
+		(match_operand:SI 2 "register_operand" "r")))]
+  ""
+{
+  return "or\\t%0, %2";
+})
+
+;; -------------------------------------------------------------------------
+;; Shifters
+;; -------------------------------------------------------------------------
+
+(define_insn "ashlsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ashift:SI (match_operand:SI 1 "register_operand" "0")
+		   (match_operand:SI 2 "register_operand" "r")))]
+  ""
+{
+  return "ashl\\t%0, %2";
+})
+
+(define_insn "ashrsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ashiftrt:SI (match_operand:SI 1 "register_operand" "0")
+		     (match_operand:SI 2 "register_operand" "r")))]
+  ""
+{
+  return "ashr\\t%0, %2";
+})
+
+(define_insn "lshrsi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(lshiftrt:SI (match_operand:SI 1 "register_operand" "0")
+		     (match_operand:SI 2 "register_operand" "r")))]
+  ""
+{
+  return "lshr\\t%0, %2";
+})
+
+;; -------------------------------------------------------------------------
+;; Move instructions
+;; -------------------------------------------------------------------------
+
+;; SImode
+
+;; Push a register onto the stack
+(define_insn "movsi_push"
+  [(set (mem:SI (pre_dec:SI (reg:SI 1)))
+  	(match_operand:SI 0 "register_operand" "r"))]
+  ""
+  "push\\t$sp, %0")
+
+;; Pop a register from the stack
+(define_insn "movsi_pop"
+  [(set (match_operand:SI 1 "register_operand" "=r")
+  	(mem:SI (post_inc:SI (match_operand:SI 0 "register_operand" "r"))))]
+  ""
+  "pop\\t%0, %1")
+
+(define_expand "movsi"
+   [(set (match_operand:SI 0 "general_operand" "")
+ 	(match_operand:SI 1 "general_operand" ""))]
+   ""
+  "
+{
+  /* If this is a store, force the value into a register.  */
+  if (! (reload_in_progress || reload_completed))
+  {
+    if (MEM_P (operands[0]))
+    {
+      operands[1] = force_reg (SImode, operands[1]);
+      if (MEM_P (XEXP (operands[0], 0)))
+        operands[0] = gen_rtx_MEM (SImode, force_reg (SImode, XEXP (operands[0], 0)));
+    }
+    else 
+      if (MEM_P (operands[1])
+          && MEM_P (XEXP (operands[1], 0)))
+        operands[1] = gen_rtx_MEM (SImode, force_reg (SImode, XEXP (operands[1], 0)));
+  }
+}")
+
+(define_insn "*movsi"
+  [(set (match_operand:SI 0 "nonimmediate_operand" "=r,r,r,W,A,r,r,B,r")
+	(match_operand:SI 1 "lldevcpu_general_movsrc_operand" "O,r,i,r,r,W,A,r,B"))]
+  "register_operand (operands[0], SImode)
+   || register_operand (operands[1], SImode)"
+  "@
+   xor\\t%0, %0
+   mov\\t%0, %1
+   ldi.l\\t%0, %1
+   st.l\\t%0, %1
+   sta.l\\t%0, %1
+   ld.l\\t%0, %1
+   lda.l\\t%0, %1
+   sto.l\\t%0, %1
+   ldo.l\\t%0, %1"
+  [(set_attr "length"	"2,2,6,2,6,2,6,4,4")])
+
+(define_insn "zero_extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
+	(zero_extend:SI (match_operand:QI 1 "nonimmediate_operand" "r,W,A,B")))]
+  ""
+  "@
+   zex.b\\t%0, %1
+   ld.b\\t%0, %1
+   lda.b\\t%0, %1
+   ldo.b\\t%0, %1"
+  [(set_attr "length" "2,2,6,4")])
+
+(define_insn "zero_extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r,r,r")
+	(zero_extend:SI (match_operand:HI 1 "nonimmediate_operand" "r,W,A,B")))]
+  ""
+  "@
+   zex.s\\t%0, %1
+   ld.s\\t%0, %1
+   lda.s\\t%0, %1
+   ldo.s\\t%0, %1"
+  [(set_attr "length" "2,2,6,4")])
+
+(define_insn "extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(sign_extend:SI (match_operand:QI 1 "nonimmediate_operand" "r")))]
+  ""
+  "@
+   sex.b\\t%0, %1"
+  [(set_attr "length" "2")])
+
+(define_insn "extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(sign_extend:SI (match_operand:HI 1 "nonimmediate_operand" "r")))]
+  ""
+  "@
+   sex.s\\t%0, %1"
+  [(set_attr "length" "2")])
+
+(define_expand "movqi"
+  [(set (match_operand:QI 0 "general_operand" "")
+	(match_operand:QI 1 "general_operand" ""))]
+  ""
+  "
+{
+  /* If this is a store, force the value into a register.  */
+  if (MEM_P (operands[0]))
+    operands[1] = force_reg (QImode, operands[1]);
+}")
+
+(define_insn "*movqi"
+  [(set (match_operand:QI 0 "nonimmediate_operand" "=r,r,r,W,A,r,r,B,r")
+	(match_operand:QI 1 "lldevcpu_general_movsrc_operand" "O,r,i,r,r,W,A,r,B"))]
+  "register_operand (operands[0], QImode)
+   || register_operand (operands[1], QImode)"
+  "@
+   xor\\t%0, %0
+   mov\\t%0, %1
+   ldi.b\\t%0, %1
+   st.b\\t%0, %1
+   sta.b\\t%0, %1
+   ld.b\\t%0, %1
+   lda.b\\t%0, %1
+   sto.b\\t%0, %1
+   ldo.b\\t%0, %1"
+  [(set_attr "length"	"2,2,6,2,6,2,6,4,4")])
+
+(define_expand "movhi"
+  [(set (match_operand:HI 0 "general_operand" "")
+	(match_operand:HI 1 "general_operand" ""))]
+  ""
+  "
+{
+  /* If this is a store, force the value into a register.  */
+  if (MEM_P (operands[0]))
+    operands[1] = force_reg (HImode, operands[1]);
+}")
+
+(define_insn "*movhi"
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,r,W,A,r,r,B,r")
+	(match_operand:HI 1 "lldevcpu_general_movsrc_operand" "O,r,i,r,r,W,A,r,B"))]
+  "(register_operand (operands[0], HImode)
+    || register_operand (operands[1], HImode))"
+  "@
+   xor\\t%0, %0
+   mov\\t%0, %1
+   ldi.s\\t%0, %1
+   st.s\\t%0, %1
+   sta.s\\t%0, %1
+   ld.s\\t%0, %1
+   lda.s\\t%0, %1
+   sto.s\\t%0, %1
+   ldo.s\\t%0, %1"
+  [(set_attr "length"	"2,2,6,2,6,2,6,4,4")])
+
+;; -------------------------------------------------------------------------
+;; Compare instructions
+;; -------------------------------------------------------------------------
+
+(define_constants
+  [(CC_REG 19)])
+
+(define_expand "cbranchsi4"
+  [(set (reg:CC CC_REG)
+        (compare:CC
+         (match_operand:SI 1 "general_operand" "")
+         (match_operand:SI 2 "general_operand" "")))
+   (set (pc)
+        (if_then_else (match_operator 0 "comparison_operator"
+                       [(reg:CC CC_REG) (const_int 0)])
+                      (label_ref (match_operand 3 "" ""))
+                      (pc)))]
+  ""
+  "
+  /* Force the compare operands into registers.  */
+  if (GET_CODE (operands[1]) != REG)
+	operands[1] = force_reg (SImode, operands[1]);
+  if (GET_CODE (operands[2]) != REG)
+	operands[2] = force_reg (SImode, operands[2]);
+  ")
+
+(define_insn "*cmpsi"
+  [(set (reg:CC CC_REG)
+	(compare
+	 (match_operand:SI 0 "register_operand" "r")
+	 (match_operand:SI 1 "register_operand"	"r")))]
+  ""
+  "cmp\\t%0, %1")
+
+
+;; -------------------------------------------------------------------------
+;; Branch instructions
+;; -------------------------------------------------------------------------
+
+(define_code_iterator cond [ne eq lt ltu gt gtu ge le geu leu])
+(define_code_attr CC [(ne "ne") (eq "eq") (lt "lt") (ltu "ltu") 
+		      (gt "gt") (gtu "gtu") (ge "ge") (le "le") 
+		      (geu "geu") (leu "leu") ])
+(define_code_attr rCC [(ne "eq") (eq "ne") (lt "ge") (ltu "geu") 
+		       (gt "le") (gtu "leu") (ge "lt") (le "gt") 
+		       (geu "ltu") (leu "gtu") ])
+
+(define_insn "*b<cond:code>"
+  [(set (pc)
+	(if_then_else (cond (reg:CC CC_REG)
+			    (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  ""
+{
+  if (get_attr_length (insn) == 2)
+    return "b<CC>\\t%l0";
+  else
+    return "b<rCC>\\t.+6\n\tjmpa   %l0";
+}
+  [(set (attr "length")
+        (if_then_else (lt (abs (minus (pc) (match_dup 0))) (const_int 1022))
+                      (const_int 2) (const_int 8)))])
+
+;; -------------------------------------------------------------------------
+;; Call and Jump instructions
+;; -------------------------------------------------------------------------
+
+(define_expand "call"
+  [(call (match_operand:QI 0 "memory_operand" "")
+		(match_operand 1 "general_operand" ""))]
+  ""
+{
+  gcc_assert (MEM_P (operands[0]));
+})
+
+(define_insn "*call"
+  [(call (mem:QI (match_operand:SI
+		  0 "nonmemory_operand" "i,r"))
+	 (match_operand 1 "" ""))]
+  ""
+  "@
+   jsra\\t%0
+   jsr\\t%0"
+  [(set_attr "length"	"6,2")])
+
+(define_expand "call_value"
+  [(set (match_operand 0 "" "")
+		(call (match_operand:QI 1 "memory_operand" "")
+		 (match_operand 2 "" "")))]
+  ""
+{
+  gcc_assert (MEM_P (operands[1]));
+})
+
+(define_insn "*call_value"
+  [(set (match_operand 0 "register_operand" "=r")
+	(call (mem:QI (match_operand:SI
+		       1 "immediate_operand" "i"))
+	      (match_operand 2 "" "")))]
+  ""
+  "jsra\\t%1"
+  [(set_attr "length"	"6")])
+
+(define_insn "*call_value_indirect"
+  [(set (match_operand 0 "register_operand" "=r")
+	(call (mem:QI (match_operand:SI
+		       1 "register_operand" "r"))
+	      (match_operand 2 "" "")))]
+  ""
+  "jsr\\t%1")
+
+(define_insn "indirect_jump"
+  [(set (pc) (match_operand:SI 0 "nonimmediate_operand" "r"))]
+  ""
+  "jmp\\t%0")
+
+(define_insn "jump"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  ""
+  "jmpa\\t%l0"
+  [(set_attr "length"	"6")])
+
+
+;; -------------------------------------------------------------------------
+;; Prologue & Epilogue
+;; -------------------------------------------------------------------------
+
+(define_expand "prologue"
+  [(clobber (const_int 0))]
+  ""
+  "
+{
+  lldevcpu_expand_prologue ();
+  DONE;
+}
+")
+
+(define_expand "epilogue"
+  [(return)]
+  ""
+  "
+{
+  lldevcpu_expand_epilogue ();
+  DONE;
+}
+")
+
+(define_insn "returner"
+  [(return)]
+  "reload_completed"
+  "ret")
diff -ruN gcc-releases-gcc-8/gcc/config/lldevcpu/lldevcpu.opt gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/lldevcpu.opt
--- gcc-releases-gcc-8/gcc/config/lldevcpu/lldevcpu.opt	1970-01-01 03:00:00.000000000 +0300
+++ gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/lldevcpu.opt	2020-06-09 20:11:55.000000000 +0300
@@ -0,0 +1,35 @@
+; Options for the lldevcpu compiler port.
+
+; Copyright (C) 2012-2018 Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+meb
+Target RejectNegative Report InverseMask(LITTLE_ENDIAN)
+Generate big-endian code.
+
+mel
+Target RejectNegative Report Mask(LITTLE_ENDIAN)
+Generate little-endian code.
+
+mmul.x
+Target Report Mask(HAS_MULX)
+Enable MUL.X and UMUL.X instructions.
+
+; Ignored by the compiler
+mno-crt0
+Target RejectNegative
diff -ruN gcc-releases-gcc-8/gcc/config/lldevcpu/lldevcpu-protos.h gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/lldevcpu-protos.h
--- gcc-releases-gcc-8/gcc/config/lldevcpu/lldevcpu-protos.h	1970-01-01 03:00:00.000000000 +0300
+++ gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/lldevcpu-protos.h	2020-06-09 20:12:53.000000000 +0300
@@ -0,0 +1,23 @@
+/* Prototypes for lldevcpu.c functions used in the md file & elsewhere.
+   Copyright (C) 2009-2018 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+extern void  lldevcpu_expand_prologue (void);
+extern void  lldevcpu_expand_epilogue (void);
+extern int   lldevcpu_initial_elimination_offset (int, int);
+extern bool  lldevcpu_offset_address_p (rtx);
diff -ruN gcc-releases-gcc-8/gcc/config/lldevcpu/predicates.md gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/predicates.md
--- gcc-releases-gcc-8/gcc/config/lldevcpu/predicates.md	1970-01-01 03:00:00.000000000 +0300
+++ gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/predicates.md	2020-06-09 20:14:09.000000000 +0300
@@ -0,0 +1,56 @@
+;; Predicate definitions for lldevcpu
+;; Copyright (C) 2009-2020 Free Software Foundation, Inc.
+;; Contributed by LLDevLab <lldevlab@gmail.com>
+
+;; This file is part of GCC.
+
+;; GCC is free software; you can redistribute it and/or modify it
+;; under the terms of the GNU General Public License as published
+;; by the Free Software Foundation; either version 3, or (at your
+;; option) any later version.
+
+;; GCC is distributed in the hope that it will be useful, but WITHOUT
+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+;; License for more details.
+
+;; You should have received a copy of the GNU General Public License
+;; along with GCC; see the file COPYING3.  If not see
+;; <http://www.gnu.org/licenses/>.
+
+;; -------------------------------------------------------------------------
+;; Predicates
+;; -------------------------------------------------------------------------
+
+;; Nonzero if OP can be source of a simple move operation.
+
+(define_predicate "lldevcpu_general_movsrc_operand"
+  (match_code "mem,const_int,reg,subreg,symbol_ref,label_ref,const")
+{
+  /* Any (MEM LABEL_REF) is OK.  That is a pc-relative load.  */
+  if (MEM_P (op) && GET_CODE (XEXP (op, 0)) == LABEL_REF)
+    return 1;
+
+  if (MEM_P (op)
+      && GET_CODE (XEXP (op, 0)) == PLUS
+      && GET_CODE (XEXP (XEXP (op, 0), 0)) == REG
+      && GET_CODE (XEXP (XEXP (op, 0), 1)) == CONST_INT
+      && IN_RANGE (INTVAL (XEXP (XEXP (op, 0), 1)), -32768, 32767))
+    return 1;
+
+  return general_operand (op, mode);
+})
+
+;; Nonzero if OP can be an operand to an add/inc/dec instruction.
+
+(define_predicate "lldevcpu_add_operand"
+  (ior (match_code "reg")
+       (and (match_code "const_int")
+	    (match_test "IN_RANGE (INTVAL (op), -255, 255)"))))
+
+;; Nonzero if OP can be an operand to an sub/dec instruction.
+
+(define_predicate "lldevcpu_sub_operand"
+  (ior (match_code "reg")
+       (and (match_code "const_int")
+	    (match_test "IN_RANGE (INTVAL (op), 0, 255)"))))
\ No newline at end of file
diff -ruN gcc-releases-gcc-8/gcc/config/lldevcpu/rtems.h gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/rtems.h
--- gcc-releases-gcc-8/gcc/config/lldevcpu/rtems.h	1970-01-01 03:00:00.000000000 +0300
+++ gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/rtems.h	2020-06-09 20:14:51.000000000 +0300
@@ -0,0 +1,40 @@
+/* Definitions for rtems targeting the lldevcpu core.
+   Copyright (C) 2010-2020 Free Software Foundation, Inc.
+   Contributed by LLDevLab <lldevlab@gmail.com>
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Target OS preprocessor built-ins.  */
+#define TARGET_OS_CPP_BUILTINS()		\
+  do						\
+    {						\
+      builtin_define_std ("lldevcpu");		\
+      builtin_define ("__rtems__");		\
+      builtin_assert ("system=rtems");		\
+    }						\
+  while (0)
+
+#undef LINK_SPEC
+#undef SIZE_TYPE
+#undef PTRDIFF_TYPE
+#undef WCHAR_TYPE
+#undef WCHAR_TYPE_SIZE
diff -ruN gcc-releases-gcc-8/gcc/config/lldevcpu/t-lldevcpu gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/t-lldevcpu
--- gcc-releases-gcc-8/gcc/config/lldevcpu/t-lldevcpu	1970-01-01 03:00:00.000000000 +0300
+++ gcc-releases-gcc-8-lldevcpu/gcc/config/lldevcpu/t-lldevcpu	2020-06-09 20:15:35.000000000 +0300
@@ -0,0 +1,23 @@
+# Target Makefile Fragment for lldevcpu
+# Copyright (C) 2008-2020 Free Software Foundation, Inc.
+# Contributed by LLDevLab.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published
+# by the Free Software Foundation; either version 3, or (at your
+# option) any later version.
+#
+# GCC is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+# License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+MULTILIB_OPTIONS     = meb/mel
+MULTILIB_DIRNAMES    = eb el
+
diff -ruN gcc-releases-gcc-8/gcc/config.gcc gcc-releases-gcc-8-lldevcpu/gcc/config.gcc
--- gcc-releases-gcc-8/gcc/config.gcc	2020-04-15 03:17:00.000000000 +0300
+++ gcc-releases-gcc-8-lldevcpu/gcc/config.gcc	2020-06-09 20:53:16.000000000 +0300
@@ -349,6 +349,10 @@
 ft32*)	cpu_type=ft32
 	target_has_targetm_common=no
 	;;
+lldevcpu*)
+	cpu_type=lldevcpu
+	target_has_targetm_common=no
+	;;
 moxie*)	cpu_type=moxie
 	target_has_targetm_common=no
 	;;
@@ -1330,6 +1334,12 @@
 	tm_file="${tm_file} dbxelf.h elfos.h moxie/moxiebox.h newlib-stdint.h"
 	tmake_file="${tmake_file} moxie/t-moxiebox"
 	;;
+lldevcpu-*-*)
+	gas=yes
+	gnu_ld=yes
+	tm_file="dbxelf.h elfos.h newlib-stdint.h ${tm_file}"
+	tmake_file="${tmake_file} lldevcpu/t-lldevcpu"
+	;;
 h8300-*-elf*)
 	tmake_file="h8300/t-h8300"
 	tm_file="h8300/h8300.h dbxelf.h elfos.h newlib-stdint.h h8300/elf.h"
